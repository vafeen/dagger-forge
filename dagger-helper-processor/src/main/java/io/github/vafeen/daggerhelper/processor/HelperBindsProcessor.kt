package io.github.vafeen.daggerhelper.processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName
import io.vafeen.daggerhelper.annotations.HelperBinds
import java.util.Locale.getDefault


class HelperBindsProcessor(
	private val codeGenerator: CodeGenerator,
	private val logger: KSPLogger,
	private val options: Map<String, String>
) : SymbolProcessor {

	// Храним все аннотированные классы для генерации одного модуля
	private val annotatedClasses = mutableListOf<Triple<KSClassDeclaration, KSType, KSType>>()

	override fun process(resolver: Resolver): List<KSAnnotated> {

		val symbols = resolver.getSymbolsWithAnnotation(HelperBinds::class.qualifiedName!!)
		val ret = mutableListOf<KSAnnotated>()

		symbols.forEach { symbol ->
			if (symbol !is KSClassDeclaration || !symbol.validate()) {
				ret.add(symbol)
				return@forEach
			}

			try {
				val annotation = symbol.annotations.firstOrNull {
					it.shortName.asString() == HelperBinds::class.simpleName
				} ?: return@forEach

				val args = annotation.arguments.associateBy(
					{ it.name?.asString() ?: "" },
					{ it.value }
				)

				val parentClass = args["parent"] as? KSType
				val moduleClass = args["module"] as? KSType

				if (parentClass == null || moduleClass == null) {
					logger.error("Missing required arguments in @HelperBinds", symbol)
					return@forEach
				}

				// Сохраняем для генерации в finish()
				annotatedClasses.add(Triple(symbol, parentClass, moduleClass))

			} catch (e: Exception) {
				logger.error("Error processing @HelperBinds: ${e.message}", symbol)
			}
		}

		return ret
	}

	override fun finish() {
		if (annotatedClasses.isEmpty()) return

		// Группируем по moduleClass
		val groupedByModule = annotatedClasses.groupBy { it.third }

		groupedByModule.forEach { (moduleClass, classes) ->
			generateModule(moduleClass, classes)
		}
	}

	private fun generateModule(
		moduleClass: KSType,
		classes: List<Triple<KSClassDeclaration, KSType, KSType>>
	) {
		if (classes.isEmpty()) return

		// Берем package из первого класса
		val packageName = classes.first().first.packageName.asString()
		val moduleClassName = moduleClass.declaration.simpleName.asString()

		// Имя сгенерированного модуля
		val generatedModuleName = "DaggerHelper${moduleClassName}"

		// Создаем интерфейс модуля
		val moduleSpec = TypeSpec.interfaceBuilder(generatedModuleName)
			.addAnnotation(
				AnnotationSpec.builder(ClassName("dagger", "Module"))
					.build()
			)
			.addSuperinterface(moduleClass.toClassName())
			.apply {
				// Добавляем методы @Binds для каждого аннотированного класса
				classes.forEach { (annotatedClass, parentClass, _) ->
					val annotatedClassName = annotatedClass.simpleName.asString()
					val parentClassName = parentClass.declaration.simpleName.asString()
					val parameterName =
						annotatedClassName.replaceFirstChar { it.lowercase(getDefault()) }

					val method = FunSpec.builder("binds$annotatedClassName")
						.addAnnotation(ClassName("dagger", "Binds"))
						.addModifiers(KModifier.ABSTRACT)
						.returns(parentClass.toTypeName())
						.addParameter(
							parameterName,
							annotatedClass.toClassName()
						)
						.build()

					addFunction(method)
				}
			}
			.build()

		// Создаем FileSpec правильно
		val fileSpec = FileSpec.builder(packageName, generatedModuleName)
			.addFileComment("Generated by HelperBinds KSP processor", arrayOf<Any>())
			.addFileComment("Do not edit!", arrayOf<Any>())
			.addImport("dagger", "Binds")
			.addImport("dagger", "Module")
			.addType(moduleSpec)  // ⬅️ Добавляем тип в файл
			.build()

		// Записываем файл
		val dependencies = Dependencies(false)
		codeGenerator.createNewFile(
			dependencies = dependencies,
			packageName = packageName,
			fileName = generatedModuleName,
			extensionName = "kt"
		).use { outputStream ->
			outputStream.writer().use { writer ->
				fileSpec.writeTo(writer)  // ⬅️ Просто пишем fileSpec
			}
		}

		logger.info("✅ Generated module: $generatedModuleName with ${classes.size} bind methods")
	}
}